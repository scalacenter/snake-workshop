"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[198],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),u=a,m=c["".concat(s,".").concat(u)]||c[u]||h[u]||o;return n?i.createElement(m,r(r({ref:t},d),{},{components:n})):i.createElement(m,r({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9518:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return d},default:function(){return c}});var i=n(7462),a=n(3366),o=(n(7294),n(3905)),r=["components"],l={sidebar_position:3},s="Building Snake",p={unversionedId:"snake/buidling-snake",id:"snake/buidling-snake",isDocsHomePage:!1,title:"Building Snake",description:"Structure",source:"@site/docs/snake/buidling-snake.md",sourceDirName:"snake",slug:"/snake/buidling-snake",permalink:"/snake-workshop/docs/snake/buidling-snake",editUrl:"https://github.com/scalacenter/snake-workshop/edit/website/website/docs/snake/buidling-snake.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Scala Basics",permalink:"/snake-workshop/docs/snake/scala-basics"}},d=[{value:"Structure",id:"structure",children:[],level:2},{value:"How to compile and run",id:"how-to-compile-and-run",children:[],level:2},{value:"Logic overview",id:"logic-overview",children:[{value:"The grid",id:"the-grid",children:[],level:3},{value:"A World example",id:"a-world-example",children:[],level:3}],level:2},{value:"Part 1: Growing the snake",id:"part-1-growing-the-snake",children:[],level:2},{value:"Part 2: Reacting to player&#39;s input",id:"part-2-reacting-to-players-input",children:[],level:2},{value:"Part 3: Moving the head",id:"part-3-moving-the-head",children:[],level:2},{value:"Part 4: Updating the Snake",id:"part-4-updating-the-snake",children:[],level:2},{value:"Part 5: Updating the world",id:"part-5-updating-the-world",children:[],level:2},{value:"Part 6: Updating the game",id:"part-6-updating-the-game",children:[],level:2}],h={toc:d};function c(e){var t=e.components,l=(0,a.Z)(e,r);return(0,o.kt)("wrapper",(0,i.Z)({},h,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"building-snake"},"Building Snake"),(0,o.kt)("h2",{id:"structure"},"Structure"),(0,o.kt)("p",null,"The code is written in three files:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"src/main/scala/Snake.scala"),": logic of the game, ",(0,o.kt)("strong",{parentName:"li"},"you will work only this file")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"src/main/scala/Launcher.scala"),": logic to start the game. This file is provided"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"src/main/scala/Painter.scala"),": logic to draw the terrain and snake on the screen. This file is provided"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"index.html"),": the web page that contains the game. Open this file in Firefox/Chrome/Safari to play")),(0,o.kt)("h2",{id:"how-to-compile-and-run"},"How to compile and run"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Start a ",(0,o.kt)("inlineCode",{parentName:"li"},"sbt")," shell. "),(0,o.kt)("li",{parentName:"ol"},"To run the game, execute the task ",(0,o.kt)("inlineCode",{parentName:"li"},"fastLinkJS"),". This will compile the Scala code into a Javascript file which you can find in ",(0,o.kt)("inlineCode",{parentName:"li"},"target/scala-3.0.2/snake-fastopt/main.js"),"."),(0,o.kt)("li",{parentName:"ol"},"Open ",(0,o.kt)("inlineCode",{parentName:"li"},"index.html")," in your browser of choice, this file loads the Javascript produced in the previous step and runs it.")),(0,o.kt)("h2",{id:"logic-overview"},"Logic overview"),(0,o.kt)("p",null,"The state of the game at any given time is represented by the ",(0,o.kt)("inlineCode",{parentName:"p"},"World")," case class"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},"case class World(snake: Snake, fruit: Fruit, size: Size)\n")),(0,o.kt)("p",null,"in other words, each object of type ",(0,o.kt)("inlineCode",{parentName:"p"},"World")," is a photograph of the state of the\ngame. It contains a snake, a fruit, and the dimensions of the world (width and\nheight)."),(0,o.kt)("p",null,"A snake is made up of blocks. Each block has ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," coordinates.  All of\nthe blocks of a snake are collected into a list.  The snake also contains the\ndirection in which it is moving."),(0,o.kt)("p",null,"The goal of this workshop is to implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"updateGame")," function which,\nprovided the previous state of the game and the action of the player, returns\nthe next state of the world."),(0,o.kt)("p",null,"The code in ",(0,o.kt)("inlineCode",{parentName:"p"},"Launcher.scala")," creates a fresh world and every 250 milliseconds\ncalls ",(0,o.kt)("inlineCode",{parentName:"p"},"nextWorld"),"."),(0,o.kt)("h3",{id:"the-grid"},"The grid"),(0,o.kt)("p",null,"The game can be represented as a table, or grid. Each element of the grid can be\nempty, occupied by a fruit or by a block of the snake.  The dimensions of the\ngrid are specified in the ",(0,o.kt)("inlineCode",{parentName:"p"},"size")," attribute of the case class\n(",(0,o.kt)("inlineCode",{parentName:"p"},"world.size.width"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"world.size.height"),"):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"height")," is the number of rows of the grid. We will use of the convention of naming ",(0,o.kt)("inlineCode",{parentName:"li"},"y")," the variables indicating vertical position"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"width")," is the number of columns of the grid. We will use of the convention of naming ",(0,o.kt)("inlineCode",{parentName:"li"},"x")," the variables indicating horizontal position"),(0,o.kt)("li",{parentName:"ul"},"The top left corner of the grid has position ",(0,o.kt)("inlineCode",{parentName:"li"},"(x=0, y=0)")),(0,o.kt)("li",{parentName:"ul"},"The top right corner of the grid has position ",(0,o.kt)("inlineCode",{parentName:"li"},"(x=width-1, y=0)")),(0,o.kt)("li",{parentName:"ul"},"The bottom left corner of the grid has position ",(0,o.kt)("inlineCode",{parentName:"li"},"(x=0, y=height-1)")),(0,o.kt)("li",{parentName:"ul"},"The bottom right corner of the grid has position ",(0,o.kt)("inlineCode",{parentName:"li"},"(x=width-1, y=height-1)"))),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"the grid",src:n(2842).Z})),(0,o.kt)("h3",{id:"a-world-example"},"A World example"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"world example",src:n(4128).Z})),(0,o.kt)("h2",{id:"part-1-growing-the-snake"},"Part 1: Growing the snake"),(0,o.kt)("p",null,"Here you will implement the eating logic of the snake.  If the snake's head\ncomes in contact with the fruit, then its tail grows one block in length.  To check if the\nhead (a ",(0,o.kt)("inlineCode",{parentName:"p"},"Block"),") is in contact with the fruit, we can compare it with the position\nof the fruit (its underlying ",(0,o.kt)("inlineCode",{parentName:"p"},"Block"),").  Remark that we are comparing two objects with the\nsame type (",(0,o.kt)("inlineCode",{parentName:"p"},"Block"),")."),(0,o.kt)("p",null,"Start by implementing the ",(0,o.kt)("inlineCode",{parentName:"p"},"eatsFruit")," function."),(0,o.kt)("p",null,"You can then move to the ",(0,o.kt)("inlineCode",{parentName:"p"},"nextTail")," functions which creates the new tail of the snake.\nTo do this, we need to understand how the snake moves:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"movement",src:n(9409).Z})),(0,o.kt)("p",null,"at each step, the head of the snake is computed (you will do this in Part 3).\nThe new head is added at beginning of the ",(0,o.kt)("inlineCode",{parentName:"p"},"body")," list of the snake.  Then the\nlast block of the snake is removed to obtain the illusion of movement: the\nnumber of blocks is constant but the position has changed. When the snake has\neaten a fruit, we still need to compute a new head, but the number of blocks\ngrows by 1. In this case, we do not need to remove the last block of the snake."),(0,o.kt)("p",null,"Implement the function ",(0,o.kt)("inlineCode",{parentName:"p"},"nextTail")," which handles both situations: when the snake\nhas eaten and it needs to grow, ",(0,o.kt)("inlineCode",{parentName:"p"},"isEating")," is set to ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," otherwise, when it\nis ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," you need to implement the movement logic described above. Make sure\nyou have a look at the ",(0,o.kt)("a",{parentName:"p",href:"docs/snake/scala-basics"},"Scala basics")," page to know how to manipulate lists."),(0,o.kt)("h2",{id:"part-2-reacting-to-players-input"},"Part 2: Reacting to player's input"),(0,o.kt)("p",null,"You will now implement two functions, ",(0,o.kt)("inlineCode",{parentName:"p"},"opposite")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"nextDirection")," so that you\ncan modify the direction of movement of the snake when the player changes it\nwith the arrow keys."),(0,o.kt)("p",null,"Start with ",(0,o.kt)("inlineCode",{parentName:"p"},"opposite"),", which you will need for ",(0,o.kt)("inlineCode",{parentName:"p"},"nextDirection"),". This function\nreturns the direction which is opposite to the one it receives. So for example\nif it receives ",(0,o.kt)("inlineCode",{parentName:"p"},"Direction.Left")," it will produce ",(0,o.kt)("inlineCode",{parentName:"p"},"Direction.Right"),".  Use pattern\nmatching (as described in ",(0,o.kt)("a",{parentName:"p",href:"docs/snake/scala-basics"},"Scala basics"),")"),(0,o.kt)("p",null,"After that you can move to ",(0,o.kt)("inlineCode",{parentName:"p"},"nextDirection"),". Here you will use pattern matching again,\nthis time on ",(0,o.kt)("inlineCode",{parentName:"p"},"Option"),", to compute the next direction of the snake.\nIf the user changed the direction, then ",(0,o.kt)("inlineCode",{parentName:"p"},"inputDirection")," will be ",(0,o.kt)("inlineCode",{parentName:"p"},"Some(...)")," and you need\nto adopt the direction in it. Otherwise you maintain (return) the current direction."),(0,o.kt)("p",null,"You need to be careful: at any time the snake can adopt three new directions,\n",(0,o.kt)("strong",{parentName:"p"},"the head cannot go inside the body"),". If the user requests this impossible\ndirection, you must keep the current direction."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"not all directions are possible",src:n(5756).Z})),(0,o.kt)("h2",{id:"part-3-moving-the-head"},"Part 3: Moving the head"),(0,o.kt)("p",null,"In this part you will update the next position of the head of the snake."),(0,o.kt)("p",null,"First, implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapY")," function, similarly to the ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapX")," above it.\nThis functions is needed so that when the snake goes against the top border of\nthe grid, it appears on the bottom of the grid going up.  You can see an example\nof the ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapX")," function:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"wrapx",src:n(439).Z})),(0,o.kt)("p",null,"You can now work on the ",(0,o.kt)("inlineCode",{parentName:"p"},"nextHead")," function. Its goal is to create the new head\nof the ",(0,o.kt)("inlineCode",{parentName:"p"},"snake")," it receives as argument. The position of the new head will depend\non the argument ",(0,o.kt)("inlineCode",{parentName:"p"},"nextDirection"),". You will create a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Block")," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"y")," attributes derived from those of the head of the snake.  Remember the\nexample grid at the beginning of this page: going right means increasing the ",(0,o.kt)("inlineCode",{parentName:"p"},"x"),"\ncomponent while the ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," component stays unchanged; going down means increasing\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," component while the ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," component stays unchanged."),(0,o.kt)("p",null,"You will need the ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapY")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapX")," functions in ",(0,o.kt)("inlineCode",{parentName:"p"},"nextHead"),"."),(0,o.kt)("h2",{id:"part-4-updating-the-snake"},"Part 4: Updating the Snake"),(0,o.kt)("p",null,"You now have all the functions required to update the direction, head and tail\nof the snake.  Use them in ",(0,o.kt)("inlineCode",{parentName:"p"},"nextSnake")," to create the snake updated for the next\nperiod. In ",(0,o.kt)("a",{parentName:"p",href:"docs/snake/scala-basics"},"Scala basics")," you will find how to combine ",(0,o.kt)("inlineCode",{parentName:"p"},"head")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"tail")," to\ncreate a new ",(0,o.kt)("inlineCode",{parentName:"p"},"body")),(0,o.kt)("h2",{id:"part-5-updating-the-world"},"Part 5: Updating the world"),(0,o.kt)("p",null,"The only moving parts of ",(0,o.kt)("inlineCode",{parentName:"p"},"World")," are ",(0,o.kt)("inlineCode",{parentName:"p"},"snake")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"fruit"),". In parts 1 to 4 you\ndeveloped the tools to detect if the snake is eating and to update its attributes.  Use them\nin ",(0,o.kt)("inlineCode",{parentName:"p"},"nextWorld")," to update the snake."),(0,o.kt)("p",null,"You also need to update the fruit: if the snake ate it, create a new one using\nthe provided function ",(0,o.kt)("inlineCode",{parentName:"p"},"createRandomFruit"),", otherwise you can reuse the existing\nfruit."),(0,o.kt)("p",null,"With the new snake and new fruit, you can return a new ",(0,o.kt)("inlineCode",{parentName:"p"},"World")," (its size remains unchanged)."),(0,o.kt)("h2",{id:"part-6-updating-the-game"},"Part 6: Updating the game"),(0,o.kt)("p",null,"In this last part you will handle a few possible events in the game."),(0,o.kt)("p",null,"Start by implementing ",(0,o.kt)("inlineCode",{parentName:"p"},"bitItself")," which is used to check if the snake has bit\nitself."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"game over",src:n(9828).Z})),(0,o.kt)("p",null,"This function is used in ",(0,o.kt)("inlineCode",{parentName:"p"},"updateGame")," to check if the game is over"),(0,o.kt)("p",null,"Finally you can implement the last three cases of the pattern match in\n",(0,o.kt)("inlineCode",{parentName:"p"},"updateGame"),": if the user presses ",(0,o.kt)("inlineCode",{parentName:"p"},"p")," the game is paused and the world does not\nchange.  Otherwise you can use the functions previously developed to update the\n",(0,o.kt)("inlineCode",{parentName:"p"},"World")))}c.isMDXComponent=!0},9828:function(e,t,n){t.Z=n.p+"assets/images/bititself-49220c28876e1459ab14cb2a7ac979e1.png"},2842:function(e,t,n){t.Z=n.p+"assets/images/grid-6a95aca42b5b9c59856f2030be90fb1e.png"},9409:function(e,t,n){t.Z=n.p+"assets/images/movement-88b978769c75533bb2d0dae0c05bbee7.png"},5756:function(e,t,n){t.Z=n.p+"assets/images/nextdirection-438419e9baeda8c7f3e3e7295d15b657.png"},4128:function(e,t,n){t.Z=n.p+"assets/images/worldexample-26e438cdfaf01bb9500fccf7ca6075bd.png"},439:function(e,t,n){t.Z=n.p+"assets/images/wrapx-0ee1f23257160b13394046ce3082812c.png"}}]);